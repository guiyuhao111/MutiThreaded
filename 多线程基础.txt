https://www.cnblogs.com/bqh10086/p/6499185.html
https://blog.csdn.net/achellies/article/details/7094467
https://blog.csdn.net/javazejian/article/details/72828483
1.java中如何实现多线程?
	---1.1.继承Thread类:是真正的处理线程的类
	---1.2.实现Runnable接口:相当于任务

2.Thread类和Runable接口上有哪些不同?
	---2.1.实现Runnable的同时可以继承其它的类,如果是继承Thread的话将不能继承其它的类
	---2.2.Runnable其实就是任务的抽象,我们实现了该任务然后将这个任务交给线程取处理, 实际上要比继承这个线程的耦合度低

3.什么叫线程安全什么叫线程不安全？
	---3.1.多个线程并发修改同一个资源时就会产生线程安全的问题。

4.线程同步的几种方法:
	4.1:synchronized介绍:
		---4.1.1:synchronized关键字可以修饰一个方法或一段代码块,此时会产生一个锁对象,当有线程尝试对这个方法和代码块进行访问时会首先尝试获取synchronized锁修饰的对象的对象锁,
		如果没有获取到对象的对象锁会进入阻塞状态直到其他线程释放该对象的对象锁.获得该对象的对象锁之后就可以运行这段代码块

		原理:当第一次有线程访问synchronized修饰的代码的时候,会修改被synchronized锁住的对象的对象头中MarkWord结构中锁标志位为01(重量级锁)并且MarkWord其他位存储Monitor对象的地址Monitor是ObjectMonitor实现的
		ObjectMonitor(锁对象)主要由_WaitSet队列 _EntrySet队列 _owner引用 _count计数,第一次进入此代码时_count属性加1,_owner指向拥有该ObjectMonitor线程的地址,其他线程再进入此代码块时会检测_count是否为0,_owner
		是否为null,不符合条件此线程会被存储在_EntrySet队列中进入阻塞状态,当拥有锁的线程运行完这段同步代码_count属性减1和_owner设置为null,_EntrySet中的线程又会竞争该ObjectMonitor
				

		---4.1.2:synchronized用来锁定某个对象，体现的是标准的互斥锁mutex的机制，synchronized代码块的开始即是lock该mutex，代码块的结束即是unlock。
		什么是互斥锁?即同一时刻只有一个线程来访问该对象

		---4.1.3:synchronized使用:
			---4.1.3.1:放在静态方法上锁的是当前类对象
			---4.1.3.2:放在普通方法上锁的是当前实例对象
			---4.1.3.3:放在方法块上锁是 Synchronized 括号里的对象

		---4.1.4:synchronized修饰代码块和方法的区别
			---4.1.4.1:修饰代码块时会通过MonitorEnter MonitorExit指令来控制这段同步代码块,当线程遇到MonitorEnter指令时会尝试获取该对象的对象锁,遇到MonitorExit指令时会释放该对象锁
				   修饰方法时通过访问该方法在方法去中保存的Acc_Synchronized标志位,如果Acc_Synchronized被设置了会尝试获取该对象的对象锁


5.如何理解锁是对象:
	---5.1.每个对象都有两个字节的对象头，对象头中存储锁状态信息。锁对象就是用来进行同步操作的bit位

6.什么是死锁?
	---6.1.死锁:多个线程都在等待对方释放锁时会产生死锁

7.线程常用方法介绍:
	---7.1:notifyAll()/notify():
		---1.修改使当前对象内置的条件变量condition，但由于mutex的存在，被阻塞线程不会立刻执行，notify()会不确定的唤醒某个线程,notifyAll()则唤醒所有线程
	---7.2:wait():
		---1.释放当前线程被synchronized所锁定mutex,只有释放掉了这个其他竞争这个互斥锁的线程才能得以运行
		---2.使当前线程阻塞在对象内置的条件变量condition (这种被阻塞的线程没有获得锁的资格)
		---3.假如被notify();和notifyAll();修改了对象内置条件变量condition,会重新锁定该对象的mutex进入就绪状态,获得锁的线程可以执行
	---7.3:sleep():使当前线程阻塞不会释放锁,任然占用操作系统所分配的时间片
	---7.4:yeild():使当前线程进入就绪状态,有可能当前线程又立刻获得操作系统分配的时间片又立刻执行

	---7.5:stop():该方法已不推荐使用
	---7.6:interrupt():该方法会将当前调用此方法的线程状态改为中断状态但是线程不会真正中断
	---7.7:isInterrupt():判断线程是否是中断状态,该方法经常配合interrupt()方法来中断线程
	---7.8:join():等待调用的线程执行完才执行当前线程

8:定时器:Timer,定时任务:TimerTask
1.相关文献:
---1.Timer是一种线程设施，用于安排以后在后台线程中执行的任务。可安排任务执行一次，或者定期重复执行，可以看成一个定时器，可以调度TimerTask。
     TimerTask是一个抽象类，实现了Runnable接口，所以具备了多线程的能力。
---2.自己的理解,Timer有两个属性:
	---1.TimerTask队列,TimerTask队列实际上是个TimerTask数组,任务执行时一个Timer可以启动多个TimerTask实际上用TimerTask队列存放
	---2.TimerThread:TimerThread继承了Thread
     TimerTask实现了Runnable接口

9:线程池详解:
public void execute(Runnable command) {
        if (command == null)
            throw new NullPointerException();
　　　　　　 //如果线程数大于等于基本线程数或者线程创建失败，将任务加入队列
        if (poolSize >= corePoolSize || !addIfUnderCorePoolSize(command)) {
　　　　　　　　　　//线程池处于运行状态并且加入队列成功
            if (runState == RUNNING && workQueue.offer(command)) {
                if (runState != RUNNING || poolSize == 0)
                    ensureQueuedTaskHandled(command);
            }
　　　　　　　　　//线程池不处于运行状态或者加入队列失败，则创建线程（创建的是非核心线程）
            else if (!addIfUnderMaximumPoolSize(command))
　　　　　　　　　　　//创建线程失败，则采取阻塞处理的方式
                reject(command); // is shutdown or saturated
        }
    }
    线程池:
1.创建线程池有哪些好处？
	---1.减少系统资源的开销,每当任务数量超过当前核心线程数就会将一部分任务队列里面直至核心线程空闲重新从任务队列里面获取数据
	---2.避免无休止的创建线程导致系统崩溃
线程池为什么能维持线程不释放，随时运行各种任务？
	1.
在线程池创建线程经历了一下几个步骤:
1.看当前线程数量是否小于核心线程数
	---小于核心线程数则创建核心线程
	---大于核心线程数量则尝试将该线程加入任务队列
2.看任务队列是否已满？
	---任务队列没满则将当前任务加入任务队列
	---任务队列已满则看当前线程池是否达到最大线程数量
3.看当前线程熟练是否达到线程池最大数量？
	---没达到当前线程池最大的任务数量则创建普通线程
	---达到当前线程任务数量则按照策略处理无法执行的任务




1.能够实现真正的并发执行吗？
---单核不行,多核CPU才可以
单核CPU也能执行多个进程，这点大家都知道。
但是并不是真正意义上的同时执行（并发执行）。
虽然在单核CPU的电脑也能开启多个进程，但这些进程并不能同时被开启和执行，而是以轮换的机制执行的（是有时间顺序的），而CPU处理某个单一的操作速度是极快的，并且极快的在进程中切换，从而让人感觉是同时运行了多个进程、同时处理多个操作。
这么做的原因之一是防止前一个任务耗时太长，导致后面简单的任务等待太久，而且电脑中有许多系统进程必须同时处于开启状态，所以CPU也必须采取这种办法来处理。
理论上讲，真正意义上的同时执行的进程数不能超过CPU核心数。 同上理，单核CPU运行多个线程是可行的。因为线程是进程中的一个实体，一个进程可以开启多个线程，所以即使只开启单个进程也能开启多个线程在单核CPU上运行。但是同上理，单核CPU并不能真正意义上的实现线程并发。
现在我们知道了，生活或工作中时常提到的所谓线程并发并非真正意义上的并发执行，这取决于CPU。

2.那么多线程实现并行处理还有必要吗？
---答案是肯定的。多线程可以实现并行处理，避免了某项任务长时间占用CPU时间。
对于单核单处理器（CPU）来说，为了运行所有这些线程，操作系统为每个独立线程安排一些CPU时间，操作系统以轮换方式向线程提供时间片，这就给人一种假象，好象这些线程都在同时运行。
既然多线程实现并发确实能够提升性能，

3.那是否使用多线程并发是必须的呢？
---答案是否定的，如果两个非常活跃的线程执行很简单的操作，为了抢夺对CPU的控制权，在线程切换时会消耗很多的CPU资源，反而会降低系统的性能。
最开始，线程只是用于分配单个处理器的处理时间的一种工具。但假如操作系统本身支持多个处理器，那么每个线程都可分配给一个不同的处理器，真正进入“并行运算”状态。从程序设计语言的角度看，多线程操作最有价值的特性之一就是程序员不必关心到底使用了多少个处理器，程序员只需将程序编写成多线程模式即可。
程序在逻辑意义上被分割为数个线程；假如机器本身安装了多个处理器，那么程序会运行得更快，毋需作出任何特殊的调校。
多线程是为了同步完成多项任务，不是为了提高运行效率，而是为了提高资源使用效率来提高系统的效率。线程是在同一时间需要完成多项任务的时候实现的。